/*
Copyright 2025 The KCP Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// swagger-schema-gen generates a swagger.json file from the OpenAPI definitions
// generated by openapi-gen. This swagger.json is consumed by
// applyconfiguration-gen via --openapi-schema to produce the SMD type
// definitions in internal.go (used by the fake client for field management).
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"k8s.io/kube-openapi/pkg/common"
	"k8s.io/kube-openapi/pkg/util"
	"k8s.io/kube-openapi/pkg/validation/spec"

	generatedopenapi "github.com/kcp-dev/kcp/pkg/openapi"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <output-file>\n", os.Args[0])
		os.Exit(1)
	}
	outputFile := os.Args[1]

	// Get all OpenAPI definitions using a ref callback that creates
	// simple schema references. Names from GetCanonicalTypeName may be
	// either Go import paths (containing "/") or model names from
	// OpenAPIModelName() (dot-separated, no "/"). Only apply
	// ToRESTFriendlyName to Go import paths; model names are already
	// in the correct format.
	refFunc := func(path string) spec.Ref {
		friendlyName := toDefName(path)
		return spec.MustCreateRef("#/definitions/" + common.EscapeJsonPointer(friendlyName))
	}
	defs := generatedopenapi.GetOpenAPIDefinitions(refFunc)

	// Build swagger definitions map using the same name normalization.
	swaggerDefs := spec.Definitions{}
	for name, def := range defs {
		swaggerDefs[toDefName(name)] = def.Schema
	}

	// Walk all schemas and add stub definitions for any $ref targets that
	// are not already in the definitions map (e.g., k8s.io/api types that
	// are referenced by KCP types but not generated by our openapi-gen).
	// applyconfiguration-gen's findReferenced panics if referenced types
	// are missing, so we add empty schemas for them.
	addMissingRefStubs(swaggerDefs)

	// Construct a minimal swagger spec with just the definitions.
	swagger := spec.Swagger{
		SwaggerProps: spec.SwaggerProps{
			Swagger: "2.0",
			Info: &spec.Info{
				InfoProps: spec.InfoProps{
					Title:   "KCP SDK OpenAPI",
					Version: "v0.1",
				},
			},
			Paths:       &spec.Paths{},
			Definitions: swaggerDefs,
		},
	}

	data, err := json.MarshalIndent(swagger, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to marshal swagger JSON: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(outputFile, data, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to write file %s: %v\n", outputFile, err)
		os.Exit(1)
	}

	fmt.Printf("Swagger schema written to %s\n", outputFile)
}

// toDefName normalises a type name for use as a swagger definition key.
// Go import paths (containing "/") are converted via ToRESTFriendlyName;
// names already in model-name format (dot-separated) are returned as-is.
func toDefName(name string) string {
	if strings.Contains(name, "/") {
		return util.ToRESTFriendlyName(name)
	}
	return name
}

// addMissingRefStubs walks all definitions and adds empty schema stubs for any
// $ref targets not present in the definitions map. This prevents
// applyconfiguration-gen from panicking on missing referenced types.
func addMissingRefStubs(defs spec.Definitions) {
	missing := map[string]bool{}
	for _, schema := range defs {
		collectMissingRefs(&schema, defs, missing)
	}
	// Keep adding stubs until no more missing refs (stubs themselves might
	// not reference anything, so one pass after initial collection suffices).
	for name := range missing {
		defs[name] = spec.Schema{}
	}
}

// collectMissingRefs recursively finds all $ref targets in a schema that are
// not present in defs.
func collectMissingRefs(schema *spec.Schema, defs spec.Definitions, missing map[string]bool) {
	if schema == nil {
		return
	}
	refPtr := schema.Ref.GetPointer()
	if refPtr != nil && !refPtr.IsEmpty() {
		name := refPtr.String()
		if strings.HasPrefix(name, "/definitions/") {
			name = strings.TrimPrefix(name, "/definitions/")
			if _, ok := defs[name]; !ok {
				if !missing[name] {
					missing[name] = true
				}
			}
		}
	}
	if schema.Items != nil {
		if schema.Items.Schema != nil {
			collectMissingRefs(schema.Items.Schema, defs, missing)
		}
		for i := range schema.Items.Schemas {
			collectMissingRefs(&schema.Items.Schemas[i], defs, missing)
		}
	}
	for _, s := range schema.AllOf {
		collectMissingRefs(&s, defs, missing)
	}
	for k := range schema.Properties {
		s := schema.Properties[k]
		collectMissingRefs(&s, defs, missing)
	}
	if schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {
		collectMissingRefs(schema.AdditionalProperties.Schema, defs, missing)
	}
}
